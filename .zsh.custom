# PROMPT
PROMPT="%% "
PROMPT2="> "
SPROMPT="%r is correct? [n,y,a,e]: "
RPROMPT='[%F{cyan}%~%f `rprompt-git-current-branch`]'
RPROMPT2="%K{green}%_%k"
## プロンプトが表示されるたびにプロンプト文字列を評価、置換する
setopt prompt_subst
## 入力が右端まで来たらプロンプトを消す
setopt transient_rprompt

## gitのカレントブランチをプロンプトに表示させる
function rprompt-git-current-branch {
  local name st color
  if [[ "$PWD" =~ '/\.git(/.*)?$' ]]; then
    return
  fi
  name=$(basename "`git symbolic-ref HEAD 2> /dev/null`")
  if [[ -z $name ]]; then
    return
  fi
  st=`git status 2> /dev/null`
  if [[ -n `echo "$st" | grep "^nothing to"` ]]; then
    color=${fg[green]}
  elif [[ -n `echo "$st" | grep "^nothing added"` ]]; then
    color=${fg[yellow]}
  elif [[ -n `echo "$st" | grep "^# Untracked"` ]]; then
    color=${fg_bold[red]}
  else
    color=${fg[red]}
  fi

  # %{...%} は囲まれた文字列がエスケープシーケンスであることを明示する
  # これをしないと右プロンプトの位置がずれる
  echo "%{$color%}$name%{$reset_color%} "
}

# history
HISTFILE=/Users/uryu/.zsh_history
HISTSIZE=100000
SAVEHIST=100000
## history(fc -l)コマンドをヒストリーリストから取り除く
setopt hist_no_store
## すぐにヒストリーファイルに追記する
setopt inc_append_history
## 直前と同じコマンドをヒストリーに追加しない
setopt hist_ignore_dups
## ヒストリーを共有
setopt share_history
## コマンドラインの先頭がスペースで始まる場合、ヒストリーに追加しない
setopt hist_ignore_space

# 補完
autoload -Uz compinit
compinit
## 補完候補を一覧表示
setopt auto_list
## 補完候補一覧でファイルの種別をマージ表示
setopt list_types
## 括弧の対応などを自動的に補完
setopt auto_param_keys
## ディレクトリ名の補完で末尾の / を自動的に付加し、次の補完に備える
setopt auto_param_slash
## 補完候補のカーソル選択を有効に
zstyle ':completion:*:default' menu select=1
## 補完候補の色づけ
#eval 'dircolors'
export ZLS_COLORS=$LS_COLORS
zstyle ':completion:*:default' list-colors ${(s.:.)LS_COLORS}
## 補完候補を詰めて表示
setopt list_packed
## ファイル名の展開でディレクトリにマッチした場合、末尾に / を付加する
setopt mark_dirs
## 最後のスラッシュを自動的に削除しない
setopt noautoremoveslash

# ビープ音鳴らさない
setopt nobeep

# 色
autoload -Uz colors
colors

# aliasも補完する
setopt complete_aliases

setopt auto_pushd
setopt pushd_ignore_dups
setopt auto_cd

zstyle ':completion:*:sudo:*' command-path /usr/local/sbin usr/local/bin \
	                                   /usr/sbin /usr/bin/ /sbin /bin

# git status のキーバインド設定
function git_status() {
  echo '\n'
  git st
  zle reset-prompt
}
zle -N git_status
bindkey '^gs' git_status

# git branch のキーバインド
function git_branch() {
  echo '\n'
  git br
  zle reset-prompt
}
zle -N git_branch
bindkey '^gb' git_branch

# git branch のキーバインド
function git_branch_all() {
  echo '\n'
  git ba
  zle reset-prompt
}
zle -N git_branch_all
bindkey '^gba' git_branch_all

# vcs_info 利用版
#RPROMPT=""
#
#autoload -Uz vcs_info
#autoload -Uz add-zsh-hook
#autoload -Uz is-at-least
#autoload -Uz colors
#
## 以下の3つのメッセージをエクスポートする
##   $vcs_info_msg_0_ : 通常メッセージ用 (緑)
##   $vcs_info_msg_1_ : 警告メッセージ用 (黄色)
##   $vcs_info_msg_2_ : エラーメッセージ用 (赤)
#zstyle ':vcs_info:*' max-exports 3
#
#zstyle ':vcs_info:*' enable git svn hg bzr
## 標準のフォーマット(git 以外で使用)
## misc(%m) は通常は空文字列に置き換えられる
#zstyle ':vcs_info:*' formats '(%s)-[%b]'
#zstyle ':vcs_info:*' actionformats '(%s)-[%b]' '%m' '<!%a>'
#zstyle ':vcs_info:(svn|bzr):*' branchformat '%b:r%r'
#zstyle ':vcs_info:bzr:*' use-simple true
#
#
#if is-at-least 4.3.10; then
#    # git 用のフォーマット
#    # git のときはステージしているかどうかを表示
#    zstyle ':vcs_info:git:*' formats '(%s)-[%b]' '%c%u %m'
#    zstyle ':vcs_info:git:*' actionformats '(%s)-[%b]' '%c%u %m' '<!%a>'
#    zstyle ':vcs_info:git:*' check-for-changes true
#    zstyle ':vcs_info:git:*' stagedstr "+"    # %c で表示する文字列
#    zstyle ':vcs_info:git:*' unstagedstr "-"  # %u で表示する文字列
#fi
#
## hooks 設定
#if is-at-least 4.3.11; then
#    # git のときはフック関数を設定する
#
#    # formats '(%s)-[%b]' '%c%u %m' , actionformats '(%s)-[%b]' '%c%u %m' '<!%a>'
#    # のメッセージを設定する直前のフック関数
#    # 今回の設定の場合はformat の時は2つ, actionformats の時は3つメッセージがあるので
#    # 各関数が最大3回呼び出される。
#    zstyle ':vcs_info:git+set-message:*' hooks \
#                                            git-hook-begin \
#                                            git-untracked \
#                                            git-push-status \
#                                            git-nomerge-branch \
#                                            git-stash-count
#
#    # フックの最初の関数
#    # git の作業コピーのあるディレクトリのみフック関数を呼び出すようにする
#    # (.git ディレクトリ内にいるときは呼び出さない)
#    # .git ディレクトリ内では git status --porcelain などがエラーになるため
#    function +vi-git-hook-begin() {
#        if [[ $(command git rev-parse --is-inside-work-tree 2> /dev/null) != 'true' ]]; then
#            # 0以外を返すとそれ以降のフック関数は呼び出されない
#            return 1
#        fi
#
#        return 0
#    }
#
#    # untracked フィアル表示
#    #
#    # untracked ファイル(バージョン管理されていないファイル)がある場合は
#    # unstaged (%u) に ? を表示
#    function +vi-git-untracked() {
#        # zstyle formats, actionformats の2番目のメッセージのみ対象にする
#        if [[ "$1" != "1" ]]; then
#            return 0
#        fi
#
#        if command git status --porcelain 2> /dev/null \
#            | awk '{print $1}' \
#            | command grep -F '??' > /dev/null 2>&1 ; then
#
#            # unstaged (%u) に追加
#            hook_com[unstaged]+='?'
#        fi
#    }
#
#    # push していないコミットの件数表示
#    #
#    # リモートリポジトリに push していないコミットの件数を
#    # pN という形式で misc (%m) に表示する
#    function +vi-git-push-status() {
#        # zstyle formats, actionformats の2番目のメッセージのみ対象にする
#        if [[ "$1" != "1" ]]; then
#            return 0
#        fi
#
#        if [[ "${hook_com[branch]}" != "master" ]]; then
#            # master ブランチでない場合は何もしない
#            return 0
#        fi
#
#        # push していないコミット数を取得する
#        local ahead
#        ahead=$(command git rev-list origin/master..master 2>/dev/null \
#            | wc -l \
#            | tr -d ' ')
#
#        if [[ "$ahead" -gt 0 ]]; then
#            # misc (%m) に追加
#            hook_com[misc]+="(p${ahead})"
#        fi
#    }
#
#    # マージしていない件数表示
#    #
#    # master 以外のブランチにいる場合に、
#    # 現在のブランチ上でまだ master にマージしていないコミットの件数を
#    # (mN) という形式で misc (%m) に表示
#    function +vi-git-nomerge-branch() {
#        # zstyle formats, actionformats の2番目のメッセージのみ対象にする
#        if [[ "$1" != "1" ]]; then
#            return 0
#        fi
#
#        if [[ "${hook_com[branch]}" == "master" ]]; then
#            # master ブランチの場合は何もしない
#            return 0
#        fi
#
#        local nomerged
#        nomerged=$(command git rev-list master..${hook_com[branch]} 2>/dev/null | wc -l | tr -d ' ')
#
#        if [[ "$nomerged" -gt 0 ]] ; then
#            # misc (%m) に追加
#            hook_com[misc]+="(m${nomerged})"
#        fi
#    }
#
#
#    # stash 件数表示
#    #
#    # stash している場合は :SN という形式で misc (%m) に表示
#    function +vi-git-stash-count() {
#        # zstyle formats, actionformats の2番目のメッセージのみ対象にする
#        if [[ "$1" != "1" ]]; then
#            return 0
#        fi
#
#        local stash
#        stash=$(command git stash list 2>/dev/null | wc -l | tr -d ' ')
#        if [[ "${stash}" -gt 0 ]]; then
#            # misc (%m) に追加
#            hook_com[misc]+=":S${stash}"
#        fi
#    }
#
#fi
#
#function _update_vcs_info_msg() {
#    local -a messages
#    local prompt
#
#    LANG=en_US.UTF-8 vcs_info
#
#    if [[ -z ${vcs_info_msg_0_} ]]; then
#        # vcs_info で何も取得していない場合はプロンプトを表示しない
#        prompt=""
#    else
#        # vcs_info で情報を取得した場合
#        # $vcs_info_msg_0_ , $vcs_info_msg_1_ , $vcs_info_msg_2_ を
#        # それぞれ緑、黄色、赤で表示する
#        [[ -n "$vcs_info_msg_0_" ]] && messages+=( "%F{green}${vcs_info_msg_0_}%f" )
#        [[ -n "$vcs_info_msg_1_" ]] && messages+=( "%F{yellow}${vcs_info_msg_1_}%f" )
#        [[ -n "$vcs_info_msg_2_" ]] && messages+=( "%F{red}${vcs_info_msg_2_}%f" )
#
#        # 間にスペースを入れて連結する
#        prompt="${(j: :)messages}"
#    fi
#
#    RPROMPT="$prompt"
#}
#add-zsh-hook precmd _update_vcs_info_msg

